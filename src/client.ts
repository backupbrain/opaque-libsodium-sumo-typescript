import * as common from "./common";

export type OprfChallenge = {
  oprfChallenge: Uint8Array;
  randomScalar: Uint8Array;
};

export let publicKey: Uint8Array | undefined = undefined;
export let privateKey: Uint8Array | undefined = undefined;
export let keyType: string | undefined = undefined;

/**
 * Generate a random scalar that's valid for an elliptic curve
 *
 * @returns Bytes[] representing a scalar
 */
const _createRandomScalar = (): Uint8Array => {
  const randomScalar = common.sodium.crypto_core_ed25519_scalar_random();
  return randomScalar;
};

/**
 * Treat the hashed password as a vector value and map it to a valid point on an elliptic curve
 *
 * @param {Bytes[]} hashedPassword
 * @returns Bytes[]
 */
const _mapHashedPasswordToEllicpicCurve = (
  hashedPassword: Uint8Array
): Uint8Array => {
  const mappedPassword =
    common.sodium.crypto_core_ed25519_from_uniform(hashedPassword);
  return mappedPassword;
};

/**
 * Hash a password using a generic hash
 *
 * @params {Bytes[]} passwordBytes
 * @returns Bytes[] hashed password
 */
const _hashPassword = (passwordBytes): Uint8Array => {
  const hashLength = common.sodium.crypto_generichash_BYTES;
  const hashedPassword = common.sodium.crypto_generichash(
    hashLength,
    passwordBytes
  );
  return hashedPassword;
};

/**
 * Create the client's OPRF challenge
 *
 * @param {string} password
 * @returns Object containing password as bytes[], hashed password, password mapped to curve, and a random number
 */
const _getCurveMappedPassword = (password: string): Uint8Array => {
  const passwordBytes = Buffer.from(password);
  const hashedPassword = _hashPassword(passwordBytes);
  const mappedPassword = _mapHashedPasswordToEllicpicCurve(hashedPassword);
  return mappedPassword;
};

/**
 * Decrypt the cipherText using the nonce and argon2 derived key
 *
 * @param {bytes[]} cipherText the encrypted cypher text
 *                  containing user public key, user secret key,
 *                  and server public key
 * @param {bytes[]} nonce a random scalar
 * @param {bytes[]} argon2DerivedKey the key derived from the
 *                  randomized password
 * @returns {object} object containing user public key, user secret key
 *                   and server public key
 */
const _openEnvelope = (
  cipherText: Uint8Array,
  nonce: Uint8Array,
  argon2DerivedKey: Uint8Array
): common.SessionKeys => {
  // Note: expect that this will throw an error if it can't be decrypted
  const messageBytes = common.sodium.crypto_secretbox_open_easy(
    cipherText,
    nonce,
    argon2DerivedKey
  );
  // const messageString = new TextDecoder('utf-8').decode(messageBytes)
  const messageString = Buffer.from(messageBytes.buffer).toString("utf-8");
  const messageData = JSON.parse(messageString);
  const userPublicKey = common.base64Decode(messageData.userPublicKey);
  const userPrivateKey = common.base64Decode(messageData.userPrivateKey);
  const serverPublicKey = common.base64Decode(messageData.serverPublicKey);
  const clientSessionKeys = common.sodium.crypto_kx_client_session_keys(
    userPublicKey,
    userPrivateKey,
    serverPublicKey
  );
  return clientSessionKeys;
};

const _createRandomizedPassword1 = (
  password: string,
  serverChallengeResponse: Uint8Array,
  oprfPublicKey: Uint8Array,
  randomScalar: Uint8Array
): Uint8Array => {
  const passwordBytes = Buffer.from(password);
  const invertedRandomScalar =
    common.sodium.crypto_core_ed25519_scalar_negate(randomScalar);
  const exponentiatedPublicKey =
    common.sodium.crypto_scalarmult_ed25519_noclamp(
      invertedRandomScalar,
      oprfPublicKey
    );
  const challengeResponseResult = common.sodium.crypto_core_ed25519_add(
    serverChallengeResponse,
    exponentiatedPublicKey
  );
  const randomizedPassword = common.sodium.crypto_generichash_batch([
    passwordBytes,
    oprfPublicKey,
    challengeResponseResult,
  ]);
  return randomizedPassword;
};

/**
 * Create an argon2 secure hash of the randomized password generated by `._createRandomizedPassword()`
 *
 * @param {bytes[]} randomizedPassword
 * @return {bytes[]} hashed randomized password
 */
const _createArgon2RandomizedPaswordHash = (
  randomizedPassword: Uint8Array
): Uint8Array => {
  // apply argon2 to rwd using the hardening params sent from the server
  const hashSalt = Buffer.alloc(common.sodium.crypto_pwhash_SALTBYTES);
  const hashOpsLimit = common.sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE;
  const hashMemLimit = common.sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE;
  const argon2HashedRandomizedPassword = common.sodium.crypto_pwhash(
    32, // TODO: replace with constant value
    randomizedPassword,
    hashSalt,
    hashOpsLimit,
    hashMemLimit,
    // TODO: check if this line needs to be crypto_pwhash_ALG_ARGON2I13
    // or possibly crypto_pwhash_ALG_ARGON2ID13
    common.sodium.crypto_pwhash_ALG_DEFAULT
  );
  return argon2HashedRandomizedPassword;
};

/**
 * Generate a public key and private key for the client
 * @returns Object containing the public key and private key
 */
export const createKeyPair = async () => {
  const keyPair = common.generateKeyPair();
  publicKey = keyPair.publicKey;
  privateKey = keyPair.privateKey;
  keyType = keyPair.keyType;
};

/**
 *
 * @param {string} password
 * @returns
 */
export const createOprfChallenge = (password: string): OprfChallenge => {
  const mappedPassword = _getCurveMappedPassword(password);
  const randomScalar = _createRandomScalar();
  const randomPointOnCurve =
    common.sodium.crypto_scalarmult_ed25519_base_noclamp(randomScalar);
  const oprfChallenge = common.sodium.crypto_core_ed25519_add(
    mappedPassword,
    randomPointOnCurve
  );
  return { oprfChallenge, randomScalar };
};

export const createSession = (
  password: string,
  cipherText: Uint8Array,
  nonce: Uint8Array,
  oprfPublicKey: Uint8Array,
  randomScalar: Uint8Array,
  serverChallengeResponse: Uint8Array
): common.SessionKeys => {
  const randomizedPassword = _createRandomizedPassword1(
    password,
    serverChallengeResponse,
    oprfPublicKey,
    randomScalar
  );
  const argon2DerivedKey =
    _createArgon2RandomizedPaswordHash(randomizedPassword);
  let clientSessionKeys: common.SessionKeys | undefined = undefined;
  try {
    clientSessionKeys = _openEnvelope(cipherText, nonce, argon2DerivedKey);
  } catch (error) {
    throw Error("Invalid password");
  }
  return clientSessionKeys;
};

export type OprfRegistrationEnvelope = {
  cipherText: Uint8Array;
  nonce: Uint8Array;
};

/**
 * Create the registration envelope, which includes
 * - a nonce
 * - a ciphertext derived from the password and the server public key
 *
 * @param {string} password the user's password
 * @param {bytes[]} randomScalar a random scalar number
 * @param {bytes[]} serverPublicKey the server's public key
 * @param {bytes[]} oprfPublicKey the public key for this authentication
 * @return {object} containing `.cipherText` an encrypted message containing
 *                  user public key, user private key, and server public key
 */
export const createOprfRegistrationEnvelope = (
  password: string,
  randomScalar: Uint8Array,
  serverChallengeResponse: Uint8Array,
  serverPublicKey: Uint8Array,
  oprfPublicKey: Uint8Array
): OprfRegistrationEnvelope => {
  const randomizedPassword = _createRandomizedPassword1(
    password,
    serverChallengeResponse,
    oprfPublicKey,
    randomScalar
  );
  const argon2DerivedKey =
    _createArgon2RandomizedPaswordHash(randomizedPassword);
  const nonce = common.generateNonce();
  const messageData = {
    userPublicKey: common.base64Encode(publicKey!),
    userPrivateKey: common.base64Encode(privateKey!),
    serverPublicKey: common.base64Encode(serverPublicKey),
  };
  const messageBytes = Buffer.from(JSON.stringify(messageData));
  const cipherText = common.sodium.crypto_secretbox_easy(
    messageBytes,
    nonce,
    argon2DerivedKey
  );
  return {
    cipherText: cipherText,
    nonce: nonce,
  };
};
